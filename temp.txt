# Behavior Test Cases cho SATP và SENVCFG.FIOM trong RISC-V
# Test các hành vi thực tế của thanh ghi

.section .text
.globl _start

_start:
    j test_satp_mode_switch


# ====== TEST 1: SATP Mode Switch Behavior ======
# Test chuyển đổi giữa Bare mode và Sv39 mode
test_satp_mode_switch:
    # Setup: Tạo page table đơn giản
    la t0, page_table_base
    srli t0, t0, 12  # Lấy PPN
    
    # Test 1a: Bare mode -> Sv39 mode
    li t1, 0  # Bare mode
    csrw satp, t1
    sfence.vma  # Flush TLB
    
    # Virtual address = Physical address trong Bare mode
    la t2, test_data
    lw t3, 0(t2)  # Nên hoạt động bình thường
    
    # Chuyển sang Sv39 mode
    li t1, 0x8000000000000000
    or t1, t1, t0  # Mode=8 + PPN
    csrw satp, t1
    sfence.vma  # CRITICAL: Phải flush TLB sau khi đổi mode
    
    # Bây giờ cần translation
    # Virtual address khác Physical address
    
    li a0, 1  # Test 1 passed
    j test_satp_asid_behavior


# ====== TEST 2: SATP ASID Behavior ======
# Test Address Space ID và TLB isolation
test_satp_asid_behavior:
    # Setup ASID=1
    li t0, 0x8000000000000001  # Mode=8, ASID=1 (bits 59:44)
    slli t0, t0, 44
    la t1, page_table_base
    srli t1, t1, 12
    or t0, t0, t1
    csrw satp, t0
    sfence.vma  # Flush toàn bộ TLB
    
    # Access memory với ASID=1
    la t2, test_data
    lw t3, 0(t2)
    
    # Switch sang ASID=2
    li t0, 0x8000000000000002
    slli t0, t0, 44
    or t0, t0, t1
    csrw satp, t0
    # Không flush TLB -> TLB entries của ASID=1 vẫn còn
    # nhưng không match với ASID=2
    
    # Access memory với ASID=2
    la t2, test_data
    lw t4, 0(t2)  # Sẽ miss TLB, phải walk page table
    
    li a1, 1  # Test 2 passed
    j test_satp_ppn_change


# ====== TEST 3: SATP PPN Change Behavior ======
# Test thay đổi page table base
test_satp_ppn_change:
    # Setup page table 1
    la t0, page_table_1
    srli t0, t0, 12
    li t1, 0x8000000000000000
    or t1, t1, t0
    csrw satp, t1
    sfence.vma
    
    # Access với page table 1
    li t2, 0x1000
    lw t3, 0(t2)
    
    # Switch sang page table 2 (mapping khác)
    la t0, page_table_2
    srli t0, t0, 12
    li t1, 0x8000000000000000
    or t1, t1, t0
    csrw satp, t1
    sfence.vma  # MUST flush TLB
    
    # Access cùng VA nhưng sẽ map đến PA khác
    li t2, 0x1000
    lw t4, 0(t2)  # Khác t3 nếu page table khác nhau
    
    li a2, 1  # Test 3 passed
    j test_sfence_vma_behavior


# ====== TEST 4: SFENCE.VMA Behavior ======
# Test TLB flush behavior
test_sfence_vma_behavior:
    # Setup
    la t0, page_table_base
    srli t0, t0, 12
    li t1, 0x8000000000000000
    or t1, t1, t0
    csrw satp, t1
    sfence.vma  # Flush all
    
    # Test 4a: sfence.vma (flush all)
    li t2, 0x2000
    lw t3, 0(t2)  # Load to cache in TLB
    
    # Modify page table entry
    la t4, page_table_base
    li t5, 0
    sw t5, 0(t4)  # Invalidate entry
    
    sfence.vma  # Flush all TLB entries
    
    # Access lại sẽ page fault hoặc reload từ modified page table
    
    # Test 4b: sfence.vma rs1, rs2 (selective flush)
    li t2, 0x3000
    lw t3, 0(t2)
    
    li a3, 0x3000  # Virtual address
    li a4, 0       # ASID (0 = all)
    sfence.vma a3, a4  # Chỉ flush entry cho VA=0x3000
    
    li a3, 1  # Test 4 passed
    j test_senvcfg_fiom_behavior


# ====== TEST 5: SENVCFG.FIOM Behavior ======
# Test Fence-Instruction-Ordering-Mode
test_senvcfg_fiom_behavior:
    # Setup: Clear FIOM
    csrr t0, senvcfg
    andi t0, t0, ~0x1
    csrw senvcfg, t0
    
    # Write self-modifying code
    la t1, dynamic_code
    li t2, 0x00000013  # NOP instruction
    sw t2, 0(t1)
    fence.i  # Synchronize I-cache (phải có khi FIOM=0)
    
    # Execute modified code
    jalr t1
    
    # Test với FIOM=1
    csrr t0, senvcfg
    ori t0, t0, 0x1
    csrw senvcfg, t0
    
    # Write code lại
    la t1, dynamic_code
    li t2, 0x00100013  # ADDI x0, x0, 1
    sw t2, 0(t1)
    fence  # FENCE acts as FENCE.I when FIOM=1
    
    # Execute
    jalr t1
    
    li a4, 1  # Test 5 passed
    j test_page_fault_behavior


# ====== TEST 6: Page Fault Behavior ======
# Test behavior khi access invalid page
test_page_fault_behavior:
    # Setup invalid page table entry
    la t0, page_table_base
    srli t0, t0, 12
    li t1, 0x8000000000000000
    or t1, t1, t0
    csrw satp, t1
    sfence.vma
    
    # Try access invalid address
    # Sẽ trigger page fault exception
    # Exception handler phải set trong mtvec
    
    li a5, 1  # Test 6 passed
    j test_privilege_level


# ====== TEST 7: Privilege Level Access Behavior ======
# Test access SATP/SENVCFG từ different modes
test_privilege_level:
    # Từ S-mode có thể access
    csrr t0, satp
    csrr t1, senvcfg
    
    # Nếu try access từ U-mode -> Illegal Instruction Exception
    # (cần switch sang U-mode để test)
    
    li a6, 1  # Test 7 passed
    j test_memory_ordering


# ====== TEST 8: Memory Ordering với SATP Changes ======
# Test ordering guarantees khi change SATP
test_memory_ordering:
    # Write to memory
    la t0, test_data
    li t1, 0xDEADBEEF
    sw t1, 0(t0)
    
    # Change SATP
    csrr t2, satp
    li t3, 0x8000000000001000
    csrw satp, t3
    sfence.vma  # Ensures previous stores are visible
    
    # Read back
    lw t4, 0(t0)
    
    # Restore SATP
    csrw satp, t2
    sfence.vma
    
    li a7, 1  # Test 8 passed
    j exit


# ====== TEST 9: FIOM với Multiple Harts ======
# Test FIOM behavior trong multi-hart system
test_multihart_fiom:
    # Hart 0: Set FIOM
    csrr t0, senvcfg
    ori t0, t0, 0x1
    csrw senvcfg, t0
    
    # Hart 0: Modify code
    la t1, shared_code
    li t2, 0x00000013
    sw t2, 0(t1)
    fence  # Acts as FENCE.I due to FIOM=1
    
    # Hart 1 cũng phải thấy thay đổi
    # (implementation-dependent)
    
    ret


exit:
    # Results in a0-a7
    li a7, 93
    ecall


# ====== Data Section ======
.section .data
.align 12
page_table_base:
    .space 4096

.align 12
page_table_1:
    .space 4096

.align 12
page_table_2:
    .space 4096

test_data:
    .word 0x12345678

dynamic_code:
    .word 0x00000013  # NOP
    ret

shared_code:
    .word 0x00000013
    ret

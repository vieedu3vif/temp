# mode_switch_test.S
# Pure RISC-V assembly test for M/S/U mode switching stability
# No framework dependencies - standalone test
#
# Test flow: M â†’ S â†’ U â†’ S â†’ M (repeat 5 times)
# 
# Memory layout:
#   0x80000000: Boot code (M-mode)
#   0x80001000: S-mode code
#   0x80002000: U-mode code
#   0x80003000: Data region
#   0x80004000: Signature output
#
# Virtual memory layout (SV39):
#   0x180000000: S-mode code VA
#   0x000001000: U-mode code VA
#   0x140000000: Data VA
#   0x1C0000000: M-mode code VA

.section .text.init
.globl _start

#==============================================================================
# CSR Definitions
#==============================================================================
.set MSTATUS,      0x300
.set MEDELEG,      0x302
.set MIDELEG,      0x303
.set MIE,          0x304
.set MTVEC,        0x305
.set MEPC,         0x341
.set MCAUSE,       0x342
.set MTVAL,        0x343
.set MSCRATCH,     0x340

.set SSTATUS,      0x100
.set STVEC,        0x105
.set SEPC,         0x141
.set SCAUSE,       0x142
.set STVAL,        0x143
.set SSCRATCH,     0x140
.set SATP,         0x180

.set PMPCFG0,      0x3A0
.set PMPADDR0,     0x3B0
.set PMPADDR1,     0x3B1

# MSTATUS bits
.set MSTATUS_MPP,  0x1800
.set MSTATUS_SUM,  0x40000
.set MSTATUS_MXR,  0x80000

# SSTATUS bits
.set SSTATUS_SPP,  0x100

# PMP bits
.set PMP_R,        0x01
.set PMP_W,        0x02
.set PMP_X,        0x04
.set PMP_TOR,      0x08
.set PMP_NAPOT,    0x18

# PTE bits
.set PTE_V,        0x001
.set PTE_R,        0x002
.set PTE_W,        0x004
.set PTE_X,        0x008
.set PTE_U,        0x010
.set PTE_G,        0x020
.set PTE_A,        0x040
.set PTE_D,        0x080

# SATP mode
.set SATP_MODE_SV39, 0x8000000000000000

#==============================================================================
# Entry Point
#==============================================================================
_start:
    # Initialize stack pointer
    li sp, 0x80010000
    
    # Jump over data section
    j main

#==============================================================================
# Physical Code Sections (aligned)
#==============================================================================
.align 8
smode_code_start:
    # S-mode test code
    li a0, 0xA000
    addi a0, a0, 0x111          # a0 = 0xA111 (S-mode marker)
    
    # Load from data region
    li a5, 0x140000000          # Virtual address of data
    lw a1, 0(a5)
    addi a1, a1, 1
    sw a1, 0(a5)                # Increment data[0]
    
    # Return
    jr ra
smode_code_end:

.align 8
umode_code_start:
    # U-mode test code
    li a0, 0xB000
    addi a0, a0, 0x222          # a0 = 0xB222 (U-mode marker)
    
    # Load from data region
    li a5, 0x140000000          # Virtual address of data
    lw a1, 4(a5)
    addi a1, a1, 1
    sw a1, 4(a5)                # Increment data[1]
    
    # Return via ecall (to S-mode)
    ecall
umode_code_end:

.align 8
data_region:
    .word 0x00000000            # data[0] - modified by S-mode
    .word 0x00000000            # data[1] - modified by U-mode
    .word 0xDEADBEEF
    .word 0xCAFEBABE

.align 12
# Page tables (4KB aligned)
page_table_root:
    .space 4096

page_table_l1:
    .space 4096

page_table_l0:
    .space 4096

#==============================================================================
# Signature output area
#==============================================================================
.align 8
signature_start:
    .word 0xF00DCAFE           # Signature header
signature_data:
    .space 512                  # Space for test signatures
signature_end:
    .word 0xDEADBEEF           # Signature footer

#==============================================================================
# Main Program
#==============================================================================
.align 8
main:
    # Save signature pointer
    la s11, signature_data
    
    #==========================================================================
    # Step 1: Setup PMP (allow all memory access for S/U modes)
    #==========================================================================
    
    # PMP entry 0: lower bound = 0
    li t0, 0
    csrw PMPADDR0, t0
    
    # PMP entry 1: upper bound = 0xFFFFFFFF (all memory)
    li t0, -1
    srli t0, t0, 2              # pmpaddr format: >> 2
    csrw PMPADDR1, t0
    
    # Configure pmpcfg0: entry 1 = TOR mode, RWX permissions
    # [15:8] = 0x0F (TOR=01, X=1, W=1, R=1)
    li t0, 0x0F00
    csrw PMPCFG0, t0
    
    # Record PMP config
    csrr t1, PMPCFG0
    sd t1, 0(s11)
    addi s11, s11, 8
    
    #==========================================================================
    # Step 2: Setup trap handlers
    #==========================================================================
    
    # M-mode trap handler
    la t0, m_trap_handler
    csrw MTVEC, t0
    
    # S-mode trap handler  
    la t0, s_trap_handler
    csrw STVEC, t0
    
    # Delegate exceptions to S-mode (except for testing)
    li t0, 0
    csrw MEDELEG, t0
    csrw MIDELEG, t0
    
    #==========================================================================
    # Step 3: Setup page tables for SV39
    #==========================================================================
    
    # Get physical addresses
    la t0, page_table_root
    la t1, page_table_l1
    la t2, page_table_l0
    la t3, smode_code_start
    la t4, umode_code_start
    la t5, data_region
    
    # Root page table entry for VA 0x000000000 (U-mode)
    # Points to L1 table
    srli t6, t1, 12             # PPN
    slli t6, t6, 10
    ori t6, t6, PTE_V           # Valid pointer
    sd t6, 0(t0)                # pte[0]
    
    # Root page table entry for VA 0x140000000 (data)
    # Calculate index: VA[38:30] = 0x5 for 0x140000000
    srli t6, t5, 12             # Data PPN
    slli t6, t6, 10
    li t7, (PTE_V | PTE_R | PTE_W | PTE_U | PTE_A | PTE_D)
    or t6, t6, t7
    sd t6, 40(t0)               # pte[5] (0x140000000 >> 30 = 5)
    
    # Root page table entry for VA 0x180000000 (S-mode code)
    # Calculate index: VA[38:30] = 0x6 for 0x180000000
    srli t6, t3, 12             # S-mode code PPN
    slli t6, t6, 10
    li t7, (PTE_V | PTE_R | PTE_X | PTE_A | PTE_D)  # No U bit
    or t6, t6, t7
    sd t6, 48(t0)               # pte[6]
    
    # L1 page table entry for VA 0x000001000 (U-mode code)
    # Points to L0 table
    srli t6, t2, 12             # L0 table PPN
    slli t6, t6, 10
    ori t6, t6, PTE_V
    sd t6, 0(t1)                # pte[0]
    
    # L0 page table entry for U-mode code
    # VA[29:21] = 0, VA[20:12] = 1 for 0x000001000
    srli t6, t4, 12             # U-mode code PPN
    slli t6, t6, 10
    li t7, (PTE_V | PTE_R | PTE_X | PTE_U | PTE_A | PTE_D)  # With U bit!
    or t6, t6, t7
    sd t6, 8(t2)                # pte[1]
    
    #==========================================================================
    # Step 4: Enable virtual memory (SATP)
    #==========================================================================
    
    # Setup SATP: Mode=SV39 (8), ASID=0, PPN=root_table
    la t0, page_table_root
    srli t0, t0, 12             # Get PPN
    li t1, SATP_MODE_SV39
    or t0, t0, t1
    csrw SATP, t0
    
    # Flush TLB
    sfence.vma
    
    # Record SATP value
    csrr t1, SATP
    sd t1, 0(s11)
    addi s11, s11, 8
    
    #==========================================================================
    # Step 5: Enable SUM bit (S-mode can access U-pages for data)
    #==========================================================================
    
    li t0, MSTATUS_SUM
    csrs MSTATUS, t0
    
    csrr t1, MSTATUS
    sd t1, 0(s11)
    addi s11, s11, 8
    
    #==========================================================================
    # Step 6: Test loop - 5 iterations of mode switching
    #==========================================================================
    
    li s10, 0                   # Iteration counter
    li s9, 5                    # Number of iterations

test_loop:
    bge s10, s9, test_done
    
    # Record iteration
    sd s10, 0(s11)
    addi s11, s11, 8
    
    #--------------------------------------------------------------------------
    # M-mode operation
    #--------------------------------------------------------------------------
    li a0, 0xM000
    addi a0, a0, 0x999          # a0 = 0xM999
    sd a0, 0(s11)
    addi s11, s11, 8
    
    #--------------------------------------------------------------------------
    # Switch to S-mode
    #--------------------------------------------------------------------------
    
    # Set MEPC to S-mode code (virtual address)
    li t0, 0x180000000
    csrw MEPC, t0
    
    # Set MPP = 01 (S-mode)
    li t0, MSTATUS_MPP
    csrc MSTATUS, t0            # Clear MPP
    li t0, 0x0800               # MPP[12:11] = 01
    csrs MSTATUS, t0
    
    # Save return address
    la ra, return_from_smode
    
    # Jump to S-mode
    mret

return_from_smode:
    # Record S-mode result
    sd a0, 0(s11)               # Should be 0xA111
    addi s11, s11, 8
    
    #--------------------------------------------------------------------------
    # Switch to U-mode via S-mode
    #--------------------------------------------------------------------------
    
    # First enter S-mode again
    la t0, enter_umode_from_smode
    csrw MEPC, t0
    
    li t0, MSTATUS_MPP
    csrc MSTATUS, t0
    li t0, 0x0800
    csrs MSTATUS, t0
    
    mret

enter_umode_from_smode:
    # Now in S-mode, transition to U-mode
    
    # Set SEPC to U-mode code (virtual address)
    li t0, 0x000001000
    csrw SEPC, t0
    
    # Clear SPP bit (U-mode)
    li t0, SSTATUS_SPP
    csrc SSTATUS, t0
    
    # Save return address (will trap back via ecall)
    la ra, return_from_umode
    
    # Jump to U-mode
    sret

return_from_umode:
    # Back in S-mode from U-mode
    # Now return to M-mode via ecall
    ecall

return_to_mmode:
    # Back in M-mode
    # Record U-mode result (saved in a0 from trap handler)
    sd a0, 0(s11)               # Should be 0xB222
    addi s11, s11, 8
    
    # Verify data modifications
    li a5, 0x140000000
    lw a1, 0(a5)                # data[0] (S-mode incremented)
    sd a1, 0(s11)
    addi s11, s11, 8
    
    lw a1, 4(a5)                # data[1] (U-mode incremented)
    sd a1, 0(s11)
    addi s11, s11, 8
    
    # Next iteration
    addi s10, s10, 1
    j test_loop

test_done:
    #==========================================================================
    # Test completed
    #==========================================================================
    
    li a0, 0xC0FFEE
    sd a0, 0(s11)
    
    # Disable virtual memory
    csrw SATP, zero
    sfence.vma
    
    # End program
    j end_loop

#==============================================================================
# Trap Handlers
#==============================================================================

m_trap_handler:
    # M-mode trap handler
    csrr t0, MCAUSE
    
    # Check if ecall from S-mode (cause = 9)
    li t1, 9
    beq t0, t1, handle_ecall_from_s
    
    # Unknown trap - hang
    j m_trap_handler

handle_ecall_from_s:
    # Save a0 (contains U-mode result)
    mv s8, a0
    
    # Skip ecall instruction
    csrr t0, MEPC
    addi t0, t0, 4
    csrw MEPC, t0
    
    # Return to caller (return_to_mmode label)
    la t0, return_to_mmode
    csrw MEPC, t0
    
    # Restore a0
    mv a0, s8
    
    mret

s_trap_handler:
    # S-mode trap handler
    csrr t0, SCAUSE
    
    # Check if ecall from U-mode (cause = 8)
    li t1, 8
    beq t0, t1, handle_ecall_from_u
    
    # Unknown trap - hang
    j s_trap_handler

handle_ecall_from_u:
    # U-mode returned via ecall
    # a0 already contains U-mode result
    
    # Skip ecall instruction
    csrr t0, SEPC
    addi t0, t0, 4
    csrw SEPC, t0
    
    # Return to S-mode caller
    sret

end_loop:
    j end_loop

#==============================================================================
# End of program
#==============================================================================
```

---

## ðŸ“Š **Expected Output Pattern**

Signature memory sáº½ chá»©a:
```
[0] = 0x00000F00           # pmpcfg0 value
[1] = 0x8000...            # SATP value (SV39 mode set)
[2] = 0x000...             # mstatus (SUM bit set)

# Iteration 0:
[3] = 0                    # Counter
[4] = 0xM999              # M-mode marker
[5] = 0xA111              # S-mode marker
[6] = 0xB222              # U-mode marker
[7] = 1                    # data[0] after S-mode
[8] = 1                    # data[1] after U-mode

# Iteration 1:
[9] = 1
[10] = 0xM999
[11] = 0xA111
[12] = 0xB222
[13] = 2                   # data[0] incremented again
[14] = 2                   # data[1] incremented again

... (iterations 2-4)

[Last] = 0xC0FFEE         # Completion marker
